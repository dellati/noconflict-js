{"body":"                                  __ _ _      _      _\r\n     _ __   ___   ___ ___  _ __  / _| (_) ___| |_   (_)___\r\n    | '_ \\ / _ \\ / __/ _ \\| '_ \\| |_| | |/ __| __|  | / __|\r\n    | | | | (_) | (_| (_) | | | |  _| | | (__| |_ _ | \\__ \\\r\n    |_| |_|\\___/ \\___\\___/|_| |_|_| |_|_|\\___|\\__(_)/ |___/\r\n                                                   |__/\r\n\r\nConflict management for JavaScript.\r\n\r\nThe world of JavaScript libraries and plugins is still somewhat of a wilderness. Some attempts to correct this (CommonJS, AMD + requirejs) go pretty far, but often at the expense of developers having to modify their dependencies, and these solutions require new projects to adopt certain conventions (which in most cases is justified).  NoConflict aims to be a bridge between the wilderness and the packaged-JavaScript world.  It promotes the use of older or otherwise packaging-unaware scripts in a controlled and conflict-free manner, and in their vanilla state, and helps library developers embed basic `noConflict` functionality with minimal effort.\r\n\r\nFeatures\r\n=========\r\n\r\n* `NoConflict` provides a unified interface for managing conflicts with global objects, whether or not those objects provide conflict management on their own.\r\n\r\n* Use `NoConflict` as a mixin, adding conflict management to your own global exports.   NoConflict weighs just 3.1k minified (1.1k gzipped), so it won't add significantly to your download weight.\r\n\r\n* Use `NoConflict` as an import tool, creating an environment for your module while restoring previous global state.\r\n\r\n* Ideal for managing resources in embedded web widgets, or any context in which the environment your module runs in is unknown or otherwise uncontrollable.\r\n\r\nSource\r\n=======\r\n\r\nThe project source and licensing information is available on [github](http://github.com/mattucf/noconflict-js).\r\n\r\nYou can view the annotated source listing [here](http://mattucf.github.com/noconflict-js/docs/noconflict.html).\r\n\r\nExamples\r\n========\r\n\r\n\r\nSingle Object\r\n-------------\r\n\r\nWith `NoConflict`, conflict management is generally a two-step process: look for an existing object matching the global name you're assigning to, and prevent your code from clobbering that object permanently.\r\n\r\n    <script type=\"text/javascript\">\r\n        var imports = NoConflict(['swfobject']);\r\n    </script>\r\n\r\n    <script type=\"text/javascript\" src=\"path/to/vanilla/swfobject.js\"></script>\r\n\r\n    <script type=\"text/javascript\">\r\n        (function () {\r\n            var swfobject = imports.get('swfobject');\r\n            // do stuff with your conflict-managed swfobject....\r\n        })();\r\n    </script>\r\n\r\n(From here forward, let's pretend the script tags are there so I don't have to type them.)\r\n\r\n\r\nMultiple Objects\r\n-----------------\r\n\r\nIf you had to manage your global objects individually as above, that wouldn't be too useful. You can do the following:\r\n\r\n    var imports = NoConflict(['swfobject', 'MyLibrary', '_', {symbol: 'jQuery', args: [true]}]);\r\n\r\n    // load scripts\r\n\r\n    imports.with(function(swfobject, MyLibrary, _, $) {\r\n        // do stuff with your conflict-managed dependencies....\r\n    });\r\n\r\nNote that `jQuery` is passed as an object: this format allows for zero or more arguments to be passed to `jQuery`'s native `noConflict` method (passing `true` in this case causes `jQuery` to remove itself and restore `$` in the global scope).  By default, `NoConflict` uses an object's native `noConflict` method if present, so in this case underscore's would be called as well.\r\n\r\n`NoConflict` will also ensure, by default, that restoring a global name's previous value will not leave it undefined, if the current value is defined. Both of these default behaviors can be overridden by passing an `options` object:\r\n\r\n    var symbols = ['swfobject', 'MyLibrary', '_', {symbol: 'jQuery', args: [true]}],\r\n        options = {\r\n            useNative: false,\r\n            ensureDefined: false\r\n        },\r\n        imports = NoConflict(symbols, options);\r\n\r\n    // ...\r\n\r\nIn this case, when conflict management occurs (i.e. when `.get()` or `.with()` are called), any names whose previous\r\nvalues were not defined are removed from global scope, and native `.noConflict()` methods are ignored.\r\n\r\n\r\nContext Option\r\n---------------\r\n\r\n`NoConflict` can operate over any object as its scope, by setting the `context` option:\r\n\r\n    var classes = {\r\n        Model: function(){},\r\n        Widget: function () {console.log(Model().value);}\r\n    };\r\n\r\n    var nc = NoConflict(['Model'], {context: classes});\r\n\r\n    classes.Model = function () {\r\n        console.log('Super-specialty variant: actually does stuff!');\r\n        this.value = 'Fusion';\r\n    };\r\n\r\n    classes.Widget(); // Logs 'Fusion'\r\n\r\n    // Restore previous state.\r\n    nc.noConflict();\r\n    classes.Widget(); // Logs undefined\r\n\r\n\r\nThe `context` option defines the object that serves as the basis for name resolution. In this case, we create a\r\n`NoConflict` instance on the `classes` scope in order to temporarily alter its state in a reversible manner.\r\n\r\n\r\n\r\nRecusal\r\n========\r\n\r\nNaturally, `NoConflict` can conflict manage itself:\r\n\r\n    var NoConflict = NoConflict.noConflict();\r\n\r\n\r\n\r\nMixin\r\n======\r\n\r\nYou can use `NoConflict`'s `mixin` method to add a `noConflict` method to your own global export\\[s\\]:\r\n\r\n    (function () {\r\n        var top = this,\r\n            MyGlobal = function () {};\r\n\r\n        NoConflict(['MyGlobal']).mixin().call(MyGlobal.prototype);\r\n\r\n        MyGlobal.prototype.awesomeness = function () {\r\n            //...\r\n        };\r\n\r\n        // ...\r\n\r\n        top.MyGlobal = MyGlobal;\r\n    })();\r\n\r\nThen users of your module can simply do the following:\r\n\r\n    var better = MyGlobal.noConflict();\r\n\r\n\"Far better,\" indeed.\r\n","note":"Don't delete this file! It's used internally to help with page regeneration.","name":"Noconflict-js","tagline":"Conflict management for JavaScript","google":""}